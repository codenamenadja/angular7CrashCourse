<section>
  <h2>Angular Architecture</h2>
  <article>
    <h3>Architecture Overview</h3>
    <p>
      앵귤러는 클라이언트사이드 어플리케이션의 HTML과 Typescript 구축하기위한 플랫폼이며 프레임워크입니다.
      이것은 당신의 앱에 불러오는 코어와 추가적인 기능을 타입스크립트 라이브러리들로 구현합니다.
      <br />
      <br />
      앵귤러 앱의 기본적인 구현 블럭은 NgModules입니다. 그것은 컴포넌트의 편집에 따라 모인 Context를 전달합니다.
      NgModules는 관련된 코드를 기능적인 세트로 수집합니다.(앵귤러 앱은 NgModules의 set으로 정의됩니다.)
      앱은 최소한 하나의 root Module을 지니고 있고 그것은 bootstrapping을 가능하도록 해주며 대개 많은 feature Modules를
      가지고 있습니다.
      <br />
      <br />
      -컴포넌트들은 views를 정의합니다. views는 앵귤러가 프로그램의 logic과 data에 따라 골라지고 수정되는 화면요소의 sets입니다.
      <br />
      -컴포넌트들은 services를 사용합니다. services는 views와 직접적인 관련되지 않은 특별한 기능을 제공합니다.
      services providers는 컴포넌트들에 의존성으로서 주입될 수 있습니다. 그것은 코드를 모듈적이고, 재사용가능한, 효율적인 것으로 해줍니다.
      <br />
      <br />
      컴포넌트들과 services들은 단순히 decorators(그들의 타입을 마크하고 앵귤러에게 어떻게 그들을 사용하는지 알려주는 metadata를 전달하는)가
      포함된 classes입니다.
      <br />
      <br />
      -컴포넌트 class를 위한 metadata는 자신을 템플릿(view를 정의하는)과 연결시킵니다.
      템플릿은 보통의 HTML에 앵귤러 directives와 binding markup을 조합합니다.
      그들은 앵귤러에게 HTML이 렌더링되기 이전에 수정되도록 합니다.
      <br />
      -service class를 위한 metadata는 정보를 제공하는데, 그 정보는 앵귤러가 컴포넌트들 사이에서
      depenency injection(DI)를 가능하도록 해줍니다.
      <br />
      <br />
      앵귤러 앱의 컴포넌트들은 주로 많은 계층적으로 arrange된 views를 정의합니다.
      앵귤러는 Router서비스를 제공함으로써, 당신이 views사이에서 navigation을 정의하는데 도움을 줍니다.
      router는 정교한 in-browser navigational capabilities(브라우저내의 네비게이션적인 능력)를 제공합니다.
    </p>
  </article>
  <article>
    <h3>Modules</h3>
    <p>
      앵귤러 NgModules는 자바스크립트의 ES2015모듈과는 다릅니다.
      NgModule은 컴포넌트들(어플리케이션 도메인, 워크플로우 또는 크게 관련된 기능의 능력에 공헌하는)의
      set를 위해 편집된 context를 선언합니다.
      NgModule은 그것의 컴포넌트들을 관련된 코드, services같은,를 form fuctional units에 관련시킵니다.
      <br />
      <br />
      모든 앵귤러앱은 root module(주로 AppModule이라 명칭되는)을 가지고 있습니다.
      rootModule은 bootstrap 매커니즘을 제공하는데 그것은 어플리케이션의 실행부 입니다.
      앱은 주로 많은 기능적 modules를 포함합니다.
      <br />
      <br />
      javascript 모듈(esmodule)들 처럼, NgModules는 다른 NgModules에서 기능을 가져올 수 있습니다.
      그리고 그들 자신의 기능을 다른 NgModules에서 사용되도록 내보낼 수 있습니다.
      예를들어 당신의 앱에서 router service를 사용하기 위해, 당신은 Router NgModule을 가져옵니다.
      <br />
      <br />
      당신의 코드를 개별적인 기능적인 모듈로 조직화하는 것은 복잡한 어플리케이션을 개발관리와 재사용을 위한 디자인구현에
      도움을 줍니다. 따라서, 이 기술은 당신이 lazy-loading의 이점을 갖도록 해줍니다.
      (lazy-loading 그것은 요구에 따라 모듈을 불러내는 것입니다.)
      그를 통해 초기시작(bootstrapping)되는 시점에 불려지는 코드의 양을 줄리기 위함입니다.
    </p>
  </article>
  <article>
    <h3>Components</h3>
    <p>
      모든 앵귤러 어플리케이션은 최소한 하나의 컴포넌트(root Component)를 가지고 있습니다.
      root Component는 컴포넌트들을 DOM(document object model)을 통해 계층적으로 연결합니다.
      각 컴포넌트는 class(어플리케이션 data and logic을 포함한)를 정의하며,
      목표한 상황(target environment)에 보여지는 HTML template와 관련되어있습니다.
      <br />
      <br />
      <i>@component()</i> decorator는 class를 즉각 소속된 컴포넌트로서 확인시켜 줍니다.
      그리고 템플릿과 관련된 component의 고유한 metadata를 관련시킵니다.
      <br />
      <br />
      Decorators는 javascript classes를 수정 및 정의하는 class입니다.
      앵귤러는 특정한 metadata들을 각각 class에 부착하는 decorators를 정의하여,
      시스템이 그 classes가 무엇을 의미하고, 그들이 무슨 일을 해야하는지 알도록 해줍니다.
    </p>
  </article>
  <article>
    <h3>Templates, directives, and data binding</h3>
    <p>
      템플릿은 HTML과 앵귤러 마크업(렌더링 이전에 HTML요소를 수정할 수 있는)을 조합합니다.
      템플릿의 directives는 프로그램 logic을 제공하며, binding markup은 어플리케이션 데이터와 DOM을 연결합니다.
      data binding에는 두 종류가 있습니다:
      <br />
      <br />
      -Event binding은 당신의 앱이 application data 업데이트를 통해 목표한 환경에서 user input에 응답하도록 해줍니다.
      <br />
      -property binding은 어플리케이션 data에서 HTML로 전환되는 값을 삽입하도록 해줍니다.
      <br />
      <br />
      view가 보여지기 이전에, 앵귤러는 directives를 평가 및 확인합니다.
      이후 HTML elemments와 DOM을 수정하기 위해 템플릿의 binding syntax를 당신의 프로그램 data와 logic에 따라 풀어냅니다.
      앵귤러는 <i>two-way</i> data binding을 지원합니다. 그것은 DOM의 변화들이 마찬가지로
      당신의 프로그램 data에도 전달되는 것을 의미합니다.
      <br />
      <br />
      당신의 템플릿은 display에서 값을 변화시키는 것을 통해 UI를 향상시키기 위하여 <i>pipes</i>를 사용할 수 있습니다.
      예를 들어, 유저의 접속지역에 따른 적절한 화폐단위나 시간을 보여주기 위해 pipes를 사용해보세요.
      앵귤러는 일반적인 전환 및 변환을 위해 미리 정의된 pipes를 지원합니다.
      그리고 당신은 자신만의 pipes를 정의할 수도 있습니다.
    </p>
  </article>
  <article>
    <h3>Services and dependency injection</h3>
    <p>
      뷰와 직접적인 관련이 없는 데이터와 로직을 위해서, 그리고 컴포넌트들 사이에서 공유하기위해서 당신은 <i>service</i> class를 생성합니다.
      service class의 정의는 즉각적으로 <i>@Injectable()</i> decorator에 의해 진행됩니다.
      decorator은 클라이언트-컴포넌트에게 dependency로서 주입되도록 허락하는 메타데이터를 공급합니다.
      <br />
      <br />
      <i>Dependency injection</i> (DI)는 당신의 컴포넌트를 의존적이고 효율적으로 만들어줍니다.
      그들(컴포넌트들)은 서버로부터 데이터를 교환하거나, user input의 유효성을 체크하거나 또는 콘솔로 직접적으로 로그를 출력하지 않습니다.
      그들은 그러한 일들을 services에 의탁(delegate)시킵니다.
    </p>
  </article>
  <article>
    <h3>Routing</h3>
    <p>
      앵귤러의 <i>Router</i> NgModule은 어플리케이션의 다른 상태와 뷰의 트리구조 사이에서 navigation path를 당신이 정의하도록 돕는 서비스를 제공합니다.
      이것은 친숙한 브라우저 navigation conventions(네비게이션 관습) 위에서 모델화 됩니다.
      <br />
      <br />
      -주소창에 URL을 입력하면 브라우저가 호환하는 페이지로 이동합니다.
      <br />
      -페이지의 링크를 클릭하면 브라우저가 새로운 창으로 이동합니다.
      <br />
      -브라우저의 뒤로가기 앞으로가기 버튼을 클릭하면 브라우저는 당신이 본 기록을 기반으로 이동합니다.
      <br />
      <br />
      router는 URL같은 주소를 페이지들이 아닌 뷰로 매핑합니다.
      유저가 행동을 취하면, 예)링크 클릭, 그것은 새로운 파이지를 브라우저로 불러올 것입니다.
      여기서 <i>router</i>는 브라우저의 행동을 intercept하여 뷰의 트리구조를 보여주거나 감추거나 하게 됩니다.
      <br />
      만약 router가 현재 어플리케이션 상태가 특정한 기능을 요구한다고 결정한다면, 그리고 해당 모듈이 아직 로드되지 않았다면,
      router는 모듈을 필요에 따라 <i>lazy-load</i> 할 수 있습니다.
      <br />
      라우터는 해당 앱의 view navigation ruls와 data state에 따라 URL링크를 해석합니다.
      당신은 유저가 버튼을 클릭하거나, 어떤 소스에서 발생한 다른 자극에 응답하기 위해 다른 새로운 view로 이동할 수 있습니다.
      router는 브라우저 기록안에 행동을 기록하고, 따라서 forward and back 버튼 또한 잘 작동할 수 있습니다.
      <br />
      네비게이션 rules를 정의하기 위해, 당신은 컴포넌트와 navigation path들을 연관시킵니다.
      path는 당신의 program data를 통합하는 URL-like syntax를 사용합니다.
      마찬가지로 동일한 방식으로 template syntax도 당신의 views를 당신의 program data와 통합시킵니다.
      그러면 당신은 어떤 뷰들을 보여주고 숨길지 정하는, user input과 당신 고유의 접근 규칙에 응답할 수 있는 program logic을 적용시킬 수 있겠지요.
    </p>
  </article>
  <article>
    <h3>What's next</h3>
    <p>
      당신은 앵귤러의 메인 구축 blocks(NgModule, component...)에 대한 기본을 습득했습니다.
      아래의 다이아그램은 이 기본적인 조각들이 관련됐는지 보여줍니다.
      <br />
        <img src="https://angular.io/generated/images/guide/architecture/overview2.png" alt="angular-relational-diagram">
      <br />
    </p>
  </article>
</section>