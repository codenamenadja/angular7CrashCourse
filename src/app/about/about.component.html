<section>
  <h2>Angular Architecture</h2>
  <article>
    <h3>Architecture Overview</h3>
    <p>
      앵귤러는 클라이언트사이드 어플리케이션의 HTML과 Typescript 구축하기위한 플랫폼이며 프레임워크입니다.
      이것은 당신의 앱에 불러오는 코어와 추가적인 기능을 타입스크립트 라이브러리들로 구현합니다.
      <br />
      <br />
      앵귤러 앱의 기본적인 구현 블럭은 NgModules입니다. 그것은 컴포넌트의 편집에 따라 모인 Context를 전달합니다.
      NgModules는 관련된 코드를 기능적인 세트로 수집합니다.(앵귤러 앱은 NgModules의 set으로 정의됩니다.)
      앱은 최소한 하나의 root Module을 지니고 있고 그것은 bootstrapping을 가능하도록 해주며 대개 많은 feature Modules를
      가지고 있습니다.
      <br />
      <br />
      -컴포넌트들은 views를 정의합니다. views는 앵귤러가 프로그램의 logic과 data에 따라 골라지고 수정되는 화면요소의 sets입니다.
      <br />
      -컴포넌트들은 services를 사용합니다. services는 views와 직접적인 관련되지 않은 특별한 기능을 제공합니다.
      services providers는 컴포넌트들에 의존성으로서 주입될 수 있습니다. 그것은 코드를 모듈적이고, 재사용가능한, 효율적인 것으로 해줍니다.
      <br />
      <br />
      컴포넌트들과 services들은 단순히 decorators(그들의 타입을 마크하고 앵귤러에게 어떻게 그들을 사용하는지 알려주는 metadata를 전달하는)가
      포함된 classes입니다.
      <br />
      <br />
      -컴포넌트 class를 위한 metadata는 자신을 템플릿(view를 정의하는)과 연결시킵니다.
      템플릿은 보통의 HTML에 앵귤러 directives와 binding markup을 조합합니다.
      그들은 앵귤러에게 HTML이 렌더링되기 이전에 수정되도록 합니다.
      <br />
      -service class를 위한 metadata는 정보를 제공하는데, 그 정보는 앵귤러가 컴포넌트들 사이에서
      depenency injection(DI)를 가능하도록 해줍니다.
      <br />
      <br />
      앵귤러 앱의 컴포넌트들은 주로 많은 계층적으로 arrange된 views를 정의합니다.
      앵귤러는 Router서비스를 제공함으로써, 당신이 views사이에서 navigation을 정의하는데 도움을 줍니다.
      router는 정교한 in-browser navigational capabilities(브라우저내의 네비게이션적인 능력)를 제공합니다.
    </p>
  </article>
  <article>
    <h3>Modules</h3>
    <p>
      앵귤러 NgModules는 자바스크립트의 ES2015모듈과는 다릅니다.
      NgModule은 컴포넌트들(어플리케이션 도메인, 워크플로우 또는 크게 관련된 기능의 능력에 공헌하는)의
      set를 위해 편집된 context를 선언합니다.
      NgModule은 그것의 컴포넌트들을 관련된 코드, services같은,를 form fuctional units에 관련시킵니다.
      <br />
      <br />
      모든 앵귤러앱은 root module(주로 AppModule이라 명칭되는)을 가지고 있습니다.
      rootModule은 bootstrap 매커니즘을 제공하는데 그것은 어플리케이션의 실행부 입니다.
      앱은 주로 많은 기능적 modules를 포함합니다.
      <br />
      <br />
      javascript 모듈(esmodule)들 처럼, NgModules는 다른 NgModules에서 기능을 가져올 수 있습니다.
      그리고 그들 자신의 기능을 다른 NgModules에서 사용되도록 내보낼 수 있습니다.
      예를들어 당신의 앱에서 router service를 사용하기 위해, 당신은 Router NgModule을 가져옵니다.
      <br />
      <br />
      당신의 코드를 개별적인 기능적인 모듈로 조직화하는 것은 복잡한 어플리케이션을 개발관리와 재사용을 위한 디자인구현에
      도움을 줍니다. 따라서, 이 기술은 당신이 lazy-loading의 이점을 갖도록 해줍니다.
      (lazy-loading 그것은 요구에 따라 모듈을 불러내는 것입니다.)
      그를 통해 초기시작(bootstrapping)되는 시점에 불려지는 코드의 양을 줄리기 위함입니다.
    </p>
  </article>
  <article>
    <h3>Components</h3>
    <p>
      모든 앵귤러 어플리케이션은 최소한 하나의 컴포넌트(root Component)를 가지고 있습니다.
      root Component는 컴포넌트들을 DOM(document object model)을 통해 계층적으로 연결합니다.
      각 컴포넌트는 class(어플리케이션 data and logic을 포함한)를 정의하며,
      목표한 상황(target environment)에 보여지는 HTML template와 관련되어있습니다.
      <br />
      <br />
      <i>@component()</i> decorator는 class를 즉각 소속된 컴포넌트로서 확인시켜 줍니다.
      그리고 템플릿과 관련된 component의 고유한 metadata를 관련시킵니다.
      <br />
      <br />
      Decorators는 javascript classes를 수정 및 정의하는 class입니다.
      앵귤러는 특정한 metadata들을 각각 class에 부착하는 decorators를 정의하여,
      시스템이 그 classes가 무엇을 의미하고, 그들이 무슨 일을 해야하는지 알도록 해줍니다.
    </p>
  </article>
  <article>
    <h3>Templates, directives, and data binding</h3>
    <p>
      템플릿은 HTML과 앵귤러 마크업(렌더링 이전에 HTML요소를 수정할 수 있는)을 조합합니다.
      템플릿의 directives는 프로그램 logic을 제공하며, binding markup은 어플리케이션 데이터와 DOM을 연결합니다.
      data binding에는 두 종류가 있습니다:
      <br />
      <br />
      -Event binding은 당신의 앱이 application data 업데이트를 통해 목표한 환경에서 user input에 응답하도록 해줍니다.
      <br />
      -property binding은 어플리케이션 data에서 HTML로 전환되는 값을 삽입하도록 해줍니다.
      <br />
      <br />
      view가 보여지기 이전에, 앵귤러는 directives를 평가 및 확인합니다.
      이후 HTML elemments와 DOM을 수정하기 위해 템플릿의 binding syntax를 당신의 프로그램 data와 logic에 따라 풀어냅니다.
      앵귤러는 <i>two-way</i> data binding을 지원합니다. 그것은 DOM의 변화들이 마찬가지로
      당신의 프로그램 data에도 전달되는 것을 의미합니다. 
      <br />
      <br />
      당신의 템플릿은 display에서 값을 변화시키는 것을 통해 UI를 향상시키기 위하여 <i>pipes</i>를 사용할 수 있습니다.
      예를 들어, 유저의 접속지역에 따른 적절한 화폐단위나 시간을 보여주기 위해 pipes를 사용해보세요.
      앵귤러는 일반적인 전환 및 변환을 위해 미리 정의된 pipes를 지원합니다.
      그리고 당신은 자신만의 pipes를 정의할 수도 있습니다.
    </p>
  </article>
</section>